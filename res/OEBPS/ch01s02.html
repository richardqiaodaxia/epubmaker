<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>What Is Objective-C?</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="sect1" title="What Is Objective-C?"><div class="titlepage"><div><div><h1 class="title"><a id="objectcpr-CHP-1-SECT-2"/>What Is Objective-C?</h1></div></div></div><p>Objective-C is an <span class="emphasis"><em>object-oriented</em></span> language:
      it supports hierarchies of substitutable types, message-passing between
      objects, and code reuse through inheritance. Objective-C adds these
      features to the familiar C programming language.</p><p>Because Objective-C is an extension of C, many properties of an
      Objective-C program depend on the underlying C development tools. Among
      these properties are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The size of scalar variables such as integers and
          floating-point numbers</p></li><li class="listitem"><p>Allowed placement of scoped declarations</p></li><li class="listitem"><p>Implicit type conversion and promotion</p></li><li class="listitem"><p>Storage of string literals</p></li><li class="listitem"><p>Preprocessor macro expansion</p></li><li class="listitem"><p>Compiler warning levels</p></li><li class="listitem"><p>Code optimization</p></li><li class="listitem"><p>Include and link search paths</p></li></ul></div><p>For more information about these topics, consult the documentation
      for your development platform and tools.</p><p>Objective-C differs from C++, another object-oriented extension of
      C, by deferring decisions until runtime that C++ would make at compile
      time. Objective-C is distinguished by the following key features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Dynamic dispatch</p></li><li class="listitem"><p>Dynamic typing</p></li><li class="listitem"><p>Dynamic loading</p></li></ul></div><div class="sect2" title="Dynamic Dispatch"><div class="titlepage"><div><div><h2 class="title"><a id="objectcpr-CHP-1-SECT-2.1"/>Dynamic Dispatch</h2></div></div></div><p>Object-oriented <a id="IXT-1-1" class="indexterm"/> <a id="IXT-1-2" class="indexterm"/> <a id="IXT-1-3" class="indexterm"/>languages replace function calls with
        <span class="emphasis"><em>messages</em></span> <a id="IXT-1-4" class="indexterm"/>. The difference is that the same message may trigger
        different code at runtime, depending on the type of the message
        <a id="IXT-1-5" class="indexterm"/>receiver. Objective-C decides dynamically—at
        runtime—what code will handle a message by searching the receiver's
        class and parent classes. (The Objective-C runtime caches the search
        results for better performance.) By contrast, a C++ compiler
        constructs a dispatch table statically—at compile time.</p><p>Because the simple linear search for a receiver used by
        Objective-C mirrors the way we think about inheritance, it's easy to
        understand how an Objective-C program works. Dynamic dispatch can
        handle changes in the inheritance hierarchy at runtime. A dynamic
        message-sending model is also more natural for distributed objects
        than a table-based model.</p></div><div class="sect2" title="Dynamic Typing"><div class="titlepage"><div><div><h2 class="title"><a id="objectcpr-CHP-1-SECT-2.2"/>Dynamic Typing</h2></div></div></div><p>Because <a id="IXT-1-6" class="indexterm"/> <a id="IXT-1-7" class="indexterm"/> <a id="IXT-1-8" class="indexterm"/>message-sending is dynamic, Objective-C lets you send
        messages to objects whose type has not been declared. The Objective-C
        environment determines dynamically—at runtime—the class of the message
        receiver and calls the appropriate code. By comparison, C++ requires
        the type of the receiver to be declared statically—at compile time—in
        order to consult dispatch tables.</p><p>Static typing allows the compiler to detect some program errors,
        but type checking is undecidable—that is, no algorithm can infallibly
        distinguish between programs that have type errors and those that do
        not. A compiler must either miss some errors or prohibit some safe
        operations. Of course, in practice compilers follow the latter course,
        so some programs that would run correctly will not compile. Dynamic
        typing admits designs whose correctness is not evident to the
        compiler.</p><p>Objective-C lets you use <a id="IXT-1-9" class="indexterm"/> <a id="IXT-1-10" class="indexterm"/>static type checking where you want it, but dynamic
        typing where you need it. This represents a move away from the
        question of <span class="emphasis"><em>What is the receiver's type at compile
        time?</em></span> to <span class="emphasis"><em>What messages does an object respond to
        at runtime?</em></span> Since programs run only at runtime, this is a
        more useful perspective.</p></div><div class="sect2" title="Dynamic Loading"><div class="titlepage"><div><div><h2 class="title"><a id="objectcpr-CHP-1-SECT-2.3"/>Dynamic Loading</h2></div></div></div><p>Because <a id="IXT-1-11" class="indexterm"/> <a id="IXT-1-12" class="indexterm"/> <a id="IXT-1-13" class="indexterm"/>the process of method dispatch is simple and uniform,
        it's easy to defer until runtime the linking of separately-compiled
        code modules. Objective-C programs can be factored into components
        that have minimal interdependency; these components can be loaded as
        needed by a running program. This makes it easier to deliver code, as
        well as content, over a network; design applications or systems that
        are distributed; or write an application that can be extended by
        third-party plug-ins.</p></div><div class="sect2" title="Which Objective-C?"><div class="titlepage"><div><div><h2 class="title"><a id="objectcpr-CHP-1-SECT-2.4"/>Which Objective-C?</h2></div></div></div><p>If you are programming in a Unix environment, you probably
        already have an Objective-C compiler: the <em class="filename">gcc</em> <a id="IXT-1-14" class="indexterm"/> <a id="IXT-1-15" class="indexterm"/> compiler, which is part of many Unix installations and
        is available under the terms of the <a id="IXT-1-16" class="indexterm"/> <a id="IXT-1-17" class="indexterm"/>GNU Public License. Because of the wide availability of
        this compiler for many software and hardware platforms, this handbook
        documents the features of the language compiled by Version 3.1 of
        <em class="filename">gcc</em>.</p><p>Apple Computer has also adopted <em class="filename">gcc</em> as the compiler for its <a id="IXT-1-18" class="indexterm"/>OS X platform, which is based on a Unix variant
        <a id="IXT-1-19" class="indexterm"/>called <a id="IXT-1-20" class="indexterm"/>Darwin. Darwin provides its own Objective-C runtime, and
        a class <a id="IXT-1-21" class="indexterm"/>library <a id="IXT-1-22" class="indexterm"/>called <a id="IXT-1-23" class="indexterm"/>Cocoa. This handbook notes the differences between the
        Darwin and GNU runtime environments, and documents the root classes
        supplied by both GNU and Cocoa.</p><p>There is also a class library <a id="IXT-1-24" class="indexterm"/>called <a id="IXT-1-25" class="indexterm"/>GNUstep, distributed under the terms of the GNU Lesser
        (Library) Public License. GNUstep is an outgrowth of the same code
        that gave rise to Cocoa, and is largely compatible with Cocoa.
        Discussions in this book of Cocoa features such as the <code class="literal">NSObject</code> root class will apply equally to
        the GNUstep version.</p></div><div class="sect2" title="How Do I Get Started?"><div class="titlepage"><div><div><h2 class="title"><a id="objectcpr-CHP-1-SECT-2.5"/>How Do I Get Started?</h2></div></div></div><p>Here <a id="IXT-1-26" class="indexterm"/>is a minimal Objective-C program. If you can
        successfully compile and run it, your Objective-C installation is
        working correctly.</p><a id="I_1_tt7"/><pre class="programlisting"><strong class="userinput"><code>#import</code></strong> &lt;objc/Object.h&gt;
<strong class="userinput"><code>int</code></strong> main(<strong class="userinput"><code>int</code></strong> argc, <strong class="userinput"><code>char</code></strong>* argv[  ]) {
  Object* <em class="replaceable"><code>obj</code></em> = [Object new];
  <strong class="userinput"><code>return</code></strong> 0;
}</pre><p>To build this program from a shell prompt, save it in a file
        named <span class="emphasis"><em>myProg.m</em></span> and issue the following commands.
        (Your platform may require a different threading library, which is
        specified in the last parameter. If you are using an integrated
        development environment, follow its documentation for building a
        program.)</p><a id="I_1_tt8"/><pre class="programlisting">gcc -c<em class="replaceable"><code>myProg.m</code></em>
gcc -o <em class="replaceable"><code>myProg</code></em> 
               <em class="replaceable"><code>myProg.o</code></em> -lobjc -lpthread</pre><p>When this little program succeeds in compiling, you are ready to
        start learning the language and writing Objective-C programs.</p></div></div></body></html>
