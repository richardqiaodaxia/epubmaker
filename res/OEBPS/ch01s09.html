<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Runtime Environment</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="sect1" title="Runtime Environment"><div class="titlepage"><div><div><h1 class="title"><a id="objectcpr-CHP-1-SECT-9"/>Runtime Environment</h1></div></div></div><p>When <a id="objectcpr-IDXTERM-412" class="indexterm"/> <a id="objectcpr-IDXTERM-413" class="indexterm"/>your Objective-C program is running, certain structures
      and services are always set up for you, even though you don't
      specifically ask for them. These serve as the counterpart to the
      compiler: together the compiler and the runtime implement the features
      that Objective-C adds to C. Most languages include runtime environments;
      Objective-C is distinctive in exposing a good part of its runtime in a
      public programming interface.</p><p>The runtime's interfaces are in <a id="IXT-1-295" class="indexterm"/>header files that will be present in any installation of
      <em class="filename">gcc</em>. (For example, in Darwin they
      reside at <span class="emphasis"><em>/usr/include/objc</em></span>. Check your compiler's
      default include paths to locate these files.) You can also download the
      source code for the runtime; examining it is a good way to learn more
      about how dynamic languages are implemented.</p><div class="sect2" title="Class Objects"><div class="titlepage"><div><div><h2 class="title"><a id="objectcpr-CHP-1-SECT-9.1"/>Class Objects</h2></div></div></div><p><a id="objectcpr-IDXTERM-415" class="indexterm"/>Class <a id="objectcpr-IDXTERM-416" class="indexterm"/>objects are objects that represent at runtime the
        classes a program is using. Because they function in the same way as
        regular objects—you can send them messages and use them in
        expressions—Objective-C unifies the treatment of classes and their
        instances.</p><p>Class objects are also called factory objects, because in their
        most common usage you send them the <code class="literal">+alloc</code> <a id="IXT-1-296" class="indexterm"/> message to create other objects.</p><p>Class objects are set up by the Objective-C compiler and
        initialized at runtime before your code needs to use them. To get a
        class object from an instance, use the <code class="literal">-class</code> <a id="IXT-1-297" class="indexterm"/> method. For example, given an instance created this
        way:</p><a id="I_1_tt60"/><pre class="programlisting"><em class="replaceable"><code>Circle</code></em>* <em class="replaceable"><code>c</code></em> = [<em class="replaceable"><code>Circle</code></em> new];</pre><p>you can retrieve the class object of that instance like
        this:</p><a id="I_1_tt61"/><pre class="programlisting">Class<em class="replaceable"><code>circleClass</code></em> = [<em class="replaceable"><code>c</code></em> class];</pre><p>Sending a message to a class object is common enough that it has
        a shortcut: just name the class as the receiver, as you do when you
        invoke <code class="literal">+alloc</code>.</p><p>In the Objective-C runtime all regular objects start with an
        <code class="literal">isa</code> <a id="IXT-1-298" class="indexterm"/> <a id="IXT-1-299" class="indexterm"/> field, pointing to their class object. The class object
        contains (or refers to) the instance methods that the object can
        respond to. In addition each class object has a <code class="literal">super_class</code> <a id="IXT-1-300" class="indexterm"/> pointer which refers to the <a id="IXT-1-301" class="indexterm"/>parent class object. For root classes—those that have no
        parents—<code class="literal">super_class</code> is set to
        <strong class="userinput"><code>Nil</code></strong>. <a class="link" href="ch01s09.html#objectcpr-CHP-1-FIG-1" title="Figure 1-1. isa and super_class define the inheritance chain">Figure 1-1</a> illustrates how
        <code class="literal">isa</code> and <code class="literal">super_class</code> work together to define the
        inheritance-chain for an object of class C, which inherits from class
        B and the root class.</p><div class="figure"><a id="objectcpr-CHP-1-FIG-1"/><div class="figure-contents"><div class="mediaobject"><a id="I_1_tt62"/><img src="httpatomoreillycomsourceoreillyimages179211.png" width="293" alt="isa and super_class define the inheritance chain"/></div></div><p class="title">Figure 1-1. isa and super_class define the inheritance chain</p></div><p>Runtime method <a id="IXT-1-302" class="indexterm"/> <a id="IXT-1-303" class="indexterm"/> <a id="IXT-1-304" class="indexterm"/>dispatch for regular objects follows this
        sequence:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Follow the receiver's <code class="literal">isa</code>
            member to its class object.</p></li><li class="listitem"><p>Search for the method in the class object's method
            list.</p></li><li class="listitem"><p>If the method is not found, follow the class object's
            <code class="literal">super_class</code> pointer to the
            parent class.</p></li><li class="listitem"><p>Repeat steps 2-3 until the method is found, or the root
            class's <code class="literal">super_class</code> pointer
            (which is <strong class="userinput"><code>Nil</code></strong>) is
            evaluated.</p></li><li class="listitem"><p>If the message is still not handled, call the object's
            <a id="IXT-1-305" class="indexterm"/> <code class="literal">-forward</code>::
            method. Both <code class="literal">Object</code> and
            <code class="literal">NSObject</code> provide this method.
            (<code class="literal">NSObject</code>'s version is
            private.) The default forwarding behavior is to abort the
            program.</p></li><li class="listitem"><p>If the object has no forwarding method, the program exits
            with an error.</p></li></ol></div><p>The call to the forwarding method completes the method
        dispatcher's role in performing the original method call: it has now
        been transformed into a different call (which is dispatched with the
        same mechanism). The <a class="link" href="ch01s11.html" title="Forwarding Messages">Section
        1.11</a> describes the subsequent steps in processing an <a id="IXTR3-595" class="indexterm"/>unhandled <a id="IXTR3-596" class="indexterm"/>message.</p></div><div class="sect2" title="Metaclass Objects"><div class="titlepage"><div><div><h2 class="title"><a id="objectcpr-CHP-1-SECT-9.2"/>Metaclass Objects</h2></div></div></div><p>If instance methods are stored in class objects, then where are
        <a id="objectcpr-IDXTERM-429" class="indexterm"/> <a id="objectcpr-IDXTERM-430" class="indexterm"/>class methods stored? Class objects themselves have
        other objects to store the methods they respond to; these are called
        <span class="emphasis"><em>metaclass objects</em></span>.</p><p>Like regular objects, class objects point to their metaclass
        objects with an <code class="literal">isa</code> <a id="IXT-1-306" class="indexterm"/> field.</p><div class="note" title="Note"><h3 class="title"><a id="ch01-21-fm2xml"/>Note</h3><p>The <code class="literal">isa</code> field of a class
          object is not inherited from a root class, but specified in the
          declaration of <code class="literal">Class</code> in
          <span class="emphasis"><em>objc.h</em></span>. Its name varies across implementations;
          this handbook uses <code class="literal">isa</code> for
          clarity. <code class="literal">isa</code> is the name used in
          Darwin.</p></div><p>This design allows class method invocation and lookup to proceed
        exactly the same way as for instance methods. Class objects stand on
        an equal footing with other objects in Objective-C: you can assign
        them to variables declared as <strong class="userinput"><code>id</code></strong>, send messages to them, and they
        inherit (class) methods from their ancestors.</p><p>The runtime relation between <a id="IXT-1-307" class="indexterm"/>classes and their metaclasses is illustrated in <a class="link" href="ch01s09.html#objectcpr-CHP-1-FIG-2" title="Figure 1-2. Classes and their metaclasses">Figure 1-2</a>.</p><div class="figure"><a id="objectcpr-CHP-1-FIG-2"/><div class="figure-contents"><div class="mediaobject"><a id="I_1_tt63"/><img src="httpatomoreillycomsourceoreillyimages179213.png" width="303" alt="Classes and their metaclasses"/></div></div><p class="title">Figure 1-2. Classes and their metaclasses</p></div><p>Metaclass objects are identical in structure to class objects.
        However, their <code class="literal">isa</code> pointers all
        refer to the root metaclass. This is a practical measure to forestall
        the need for an infinite hierarchy of meta-metaclasses. (Effectively,
        the root class is the meta-metaclass of all its descendants.) Since
        you don't normally use metaclass objects, this is not a major blemish
        on the consistency of Objective-C.</p><div class="note" title="Note"><h3 class="title"><a id="ch01-22-fm2xml"/>Note</h3><p>The <a id="IXT-1-308" class="indexterm"/>GNU runtime distinguishes between class and metaclass
          objects more than the <a id="IXT-1-309" class="indexterm"/>Darwin runtime does. In the GNU runtime there are
          distinct <code class="literal">Class</code> and <code class="literal">MetaClass</code> types (although they are just
          typedefs for identical structures). Some of the reflection methods
          (like <code class="literal">-isKindOf</code>:) of <code class="literal">Object</code> behave differently from the Darwin
          version when passed metaclass objects. The exact behavior of these
          methods is described in the <a class="link" href="ch01s10.html" title="Root Classes">Section 1.10</a>.</p></div><p><a class="link" href="ch01s09.html#objectcpr-CHP-1-FIG-2" title="Figure 1-2. Classes and their metaclasses">Figure 1-2</a> shows
        one other distinctive asymmetry in the otherwise uniform structure of
        the runtime environment: the root metaclass's <code class="literal">super_class</code> <a id="IXT-1-310" class="indexterm"/> pointer refers to the root class object. This means
        that class objects behave as if they are instances of their root
        class: class objects will respond not only to their own class messages
        and those of their parent classes (including those of the root), but
        also to instance messages of the root <a id="IXTR3-597" class="indexterm"/> <a id="IXTR3-598" class="indexterm"/>class.</p></div><div class="sect2" title="Selectors"><div class="titlepage"><div><div><h2 class="title"><a id="objectcpr-CHP-1-SECT-9.3"/>Selectors</h2></div></div></div><p>For <a id="IXT-1-311" class="indexterm"/>efficiency, method dispatch doesn't look up method names
        with string comparisons. Instead method names are mapped one-to-one
        with selectors—variables of type <strong class="userinput"><code>SEL</code></strong> <a id="IXT-1-312" class="indexterm"/>. This mapping is known to both the compiler and the
        runtime system. If you want pass a method around as a parameter and
        invoke it through that parameter, you can use a <strong class="userinput"><code>SEL</code></strong> along with one of the <code class="literal">-perform</code> <a id="IXT-1-313" class="indexterm"/>: methods. (The <a class="link" href="ch01s03.html#objectcpr-CHP-1-SECT-3.5" title="Methods">Section 1.3.5</a> gives an
        example of this.)</p></div><div class="sect2" title="Protocol Objects"><div class="titlepage"><div><div><h2 class="title"><a id="objectcpr-CHP-1-SECT-9.4"/>Protocol Objects</h2></div></div></div><p>The <a id="IXT-1-314" class="indexterm"/>runtime also defines objects for each protocol in your
        program. You can retrieve these objects using the <strong class="userinput"><code>@protocol</code></strong> <a id="IXT-1-315" class="indexterm"/> directive:</p><a id="I_1_tt64"/><pre class="programlisting">Protocol*<em class="replaceable"><code>p</code></em> = <strong class="userinput"><code>@protocol</code></strong>(<em class="replaceable"><code>ProtocolName</code></em>);</pre><p>You can't do much with a protocol instance except pass it to
        root class methods that take protocols as parameters, or send the
        <code class="literal">-conformsTo</code>: message to it in order
        to see whether it conforms to yet another <a id="IXTR3-599" class="indexterm"/> <a id="IXTR3-600" class="indexterm"/>protocol.</p></div></div></body></html>
