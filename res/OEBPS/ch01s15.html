<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Optimizing Method Calls</title><link rel="stylesheet" href="core.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="sect1" title="Optimizing Method Calls"><div class="titlepage"><div><div><h1 class="title"><a id="objectcpr-CHP-1-SECT-15"/>Optimizing Method Calls</h1></div></div></div><p>Objective-C's <a id="objectcpr-IDXTERM-736" class="indexterm"/> <a id="objectcpr-IDXTERM-737" class="indexterm"/> <a id="objectcpr-IDXTERM-738" class="indexterm"/>message-passing implementation of method calls is simple
      and flexible. What it sacrifices is the speed of a C++-style method
      call, or of a direct function call.</p><p>If you are writing time-critical code, you may want to relinquish
      the dynamic nature of the Objective-C method call for some extra speed.
      For example, if your code calls the same method on an object many times
      in a loop, you may not want to send a dynamic message each time you
      invoke the method. Objective-C provides a way for you to get a pointer
      to the function implementing the method, and then call the method via
      the pointer, bypassing the Objective-C method dispatch process.</p><div class="note" title="Note"><h3 class="title"><a id="ch01-31-fm2xml"/>Note</h3><p>If you only call a method once, you should use a standard
        Objective-C method call. This optimization's gain in efficiency is
        directly related to the number of times you invoke the method.</p></div><p>For example, suppose you want to send the following message to
      invoke a method that takes an integer and has no return value:</p><a id="I_1_tt162"/><pre class="programlisting">[<em class="replaceable"><code>obj</code></em> 
            <em class="replaceable"><code>methodName</code></em>:<em class="replaceable"><code>anInt</code></em>];</pre><p>You can replace this ordinary Objective-C method call with the
      following code:</p><a id="I_1_tt163"/><pre class="programlisting">1<strong class="userinput"><code>SEL</code></strong> 
            <em class="replaceable"><code>sel</code></em> = <strong class="userinput"><code>@selector</code></strong>(<em class="replaceable"><code>methodName</code></em>:);
2 <strong class="userinput"><code>typedef void</code></strong> (*<em class="replaceable"><code>MpType</code></em>) (<strong class="userinput"><code>id</code></strong>, <strong class="userinput"><code>SEL</code></strong>, <strong class="userinput"><code>int</code></strong>);
3 <em class="replaceable"><code>MpType</code></em> 
            <em class="replaceable"><code>mptr</code></em> = (<em class="replaceable"><code>MpType</code></em>) [<em class="replaceable"><code>obj</code></em> methodFor:<em class="replaceable"><code>sel</code></em>];
4 ...
5 <em class="replaceable"><code>mptr</code></em>(<em class="replaceable"><code>obj</code></em>, <em class="replaceable"><code>sel</code></em>, <em class="replaceable"><code>anInt</code></em>);</pre><p>Line 1. Get the selector for the method you want to call. You will
      use this both to acquire the method pointer and to use it.</p><p>Line 2. Define the type of your method pointer. This makes line 3
      easier to read. Recall that methods are just C functions with two hidden
      parameters: the receiver and the selector. Here, the type of <code class="literal">mptr</code> takes these into account, as well as the
      return (<strong class="userinput"><code>void</code></strong>) and parameter
      (<strong class="userinput"><code>int</code></strong>) types of the method.</p><p>Line 3. Get the function pointer. If you already have the receiver
      at hand (as in this example) you can use <code class="literal">-methodFor</code> <a id="IXT-1-525" class="indexterm"/>: (for descendants of <code class="literal">Object</code>) or <code class="literal">-methodForSelector</code> <a id="IXT-1-526" class="indexterm"/>: (for descendants of <code class="literal">NSObject</code>). If you don't have the receiver or
      an object of the same type, you can call the class methods <code class="literal">+instanceMethodFor</code> <a id="IXT-1-527" class="indexterm"/>: (for subclasses of <code class="literal">Object</code>) or <code class="literal">+instanceMethodForSelector</code> <a id="IXT-1-528" class="indexterm"/>: (for subclasses of <code class="literal">NSObject</code>) on the class of the object whose
      method you will call.</p><p>Since these methods are declared to return an <strong class="userinput"><code>IMP</code></strong>, which is a pointer to a function whose
      signature is <code class="literal">(</code> <strong class="userinput"><code>id</code></strong>, <strong class="userinput"><code>SEL</code></strong> <code class="literal">,
      ...)</code> you need to cast to your own type the value it returns,
      to prevent compiler warnings at line 5.</p><p>Line 5. Use the function pointer as in C. Pass in the receiver and
      selector as the first two arguments. After you execute lines 1-3, line 5
      will have the same effect as calling <code class="literal">[</code> <em class="replaceable"><code>obj</code></em>
      <em class="replaceable"><code>methodName</code></em>:<em class="replaceable"><code>anInt</code></em>
      <code class="literal">]</code>, but will execute faster. Typically
      this line will be in a loop.</p><p>Optimizing a method call in this manner only makes sense when you
      are going to invoke the method repeatedly, such as within a loop. Lines
      1 through 3 represent a one-time setup that should be done prior to
      entering the loop. Line 5 is the optimized method call that would be
      used inside the <a id="IXTR3-642" class="indexterm"/>
      <a id="IXTR3-643" class="indexterm"/> <a id="IXTR3-644" class="indexterm"/>loop.</p></div></body></html>
