<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
        PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>进程同步</title>
</head>
<body>
<h2 id="anchor001">进程之间的同步</h2><br/>
进程的同步是指一组共行进程，各自以独立的、不可预知的速度向前推荐，在前进过程中彼此之间需要互相协调步伐，
才能正确地完成同一项任务。例如管道命令，就是需要两个进程合作的典型例子。<br/>

<p id="anchor002">进程间的互斥</p>
1、临界资源和临界区<br/>
进程之间的互斥是由于共享资源而引起的。为了描述这类情况，引入临界资源和临界区的概念。所谓临界资源，就是
一次仅允许一个进程使用的系统中的一些共享资源。这些资源既包括慢速的硬设备，也包括软件资源。<br/>
临界区就是并发进程访问临界资源的那段必须互斥执行的程序段。显然，一个变量可以有几个相关的临界区。<br/>

<p>2、解决进程之间互斥的硬件实现方法</p>
为了使进程互斥地进入临界区执行，可以采用如下解决方法。<br/>
<ol>
    <li>关中断</li>
    <li>使用测试和设置硬件指令</li>
</ol>
<p id="anchor003">信号量和P,V操作</p>
信号量：Semaphores。信号量表示系统共享资源的物理实体，它用一种数据结构描述：
<pre>
<code>
    typedef struct{
    int value;
    struct process *list;
    }semaphore;
</code>
</pre>
<br/>
其中，value使一个整形变量，其值大小表示该类资源的可用数量。<br/>
对于信号量s的操作只允许执行P, V原语操作。<br/>
P操作用P(s)表示，描述为执行P操作时，将信号量s.value的值减1，若s.value &gt;= 0，则执行
P操作的进程继续执行；若s.value&lt;0 则执行P操作的进程状态变为阻塞状态，并排到与该信号量有关
的List所指队列中等待。<br/>
V操作用V(s)表示，描述为：执行V操作时，将信号量s.value的值加1，若s.value的值不大于0，则执行V操作的
进程从与该信号量有关的list所指队列中释放一个进程，使它由阻塞变为就绪状态。<br/>
从物理意义上理解，P操作相当于申请资源，V操作相当于释放资源。<br/>

<p id="anchor004">1.利用信号量实现进程之间的互斥</p>为了正确地解决一组并发进程对临界资源的互斥共享，这里引入一个互斥
信号量，用mutex表示。对于互斥使用的资源，其信号量的初始值只能为1。任何欲进入临界区执行的进程，
必须先对互斥信号量mutex执行P操作，即将mutex值减1。若减1后mutex值为0，表示临界资源区空闲，执行P操作
的进程可以进入临界区执行；若mutex减1后的值为负，说明已有进程正在临界区执行，执行P操作的进程必须等待，
直到临界区空闲为止。正在临界区执行的进程，完成临界区操作后，通过执行V操作释放临界资源，
使等待使用临界资源的进程使用。这样，利用信号量方便地解决了临界区的互斥访问。<br/>

<p id="anchor005">4.生产者和消费者问题</p><br/>
计算机中进程之间的同步问题可以一般化为生产者和消费者问题。运行中的进程当其释放一个资源时，
可把它看成是该资源的生产者。而当其申请使用一个资源时，又可看成是该资源的消费者。<br/>
用信号量解决这个问题，必须定义如下一些信号量:<br/>
<ol>
    <li>互斥信号量mutex，以控制生产者和消费者互斥使用缓冲区。mutex初值为1</li>
    <li>同步信号量empty，表示空缓冲区的可用数量，用于制约生产者进程送产品，初值为k</li>
    <li>同步信号量full，指示装满产品的缓冲区个数，以制约消费者进程取产品，初值为0</li>
    <li>设置两个送取产品的指针变量i,j，初值都为0</li>
    <li>两个临时变量x,y，分别用来代表送和取的产品</li>
</ol>
<br/>
现将生产者和消费者问题描述如下：<br/>
<pre>
<code>
    mutex,empty,full:integer;
    mutex:=1;empty:=k;full:=0;
    array[0...n-1]:integer; // 缓冲区的定义
    i:=0,j:=0:integer; //缓冲区的送取产品的指针
    x,y,item; // 产品变量
    parbegin
    producer: begin // 用来发送，必须使用空缓冲
      produce a product to x;
      P(empty); // 申请空缓冲区 申请好采用array
      P(mutex); // 申请进入缓冲区
      array[i] = x; // 将产品加入缓冲区
      i:=(i+1) mod k; // 修改缓冲区的送产品指针
      V(full); // 释放一个产品
      V(mutex); // 退出缓冲区
    end;
    consumer: begin // 获取一定要从full信号量开始，因为要获取
      P(full);  // 申请一个产品
      P(mutex); // 申请缓冲区
      y=array[j]; // 从缓冲区获取产品
      j:=(j+1) mod k;
      V(empty); // 释放缓冲区，从full取出，那么就增加empty
      V(mutex); // 退出缓冲区
    end;
    parend;
</code>
</pre><br/>
应该注意，无论是生产者还是消费者，P操作的顺序是重要的。如果把生产者进程中的两个P操作的次序交换，
当缓冲区满时，生产者欲向缓冲区方产品时，由于申请使用缓冲区不成功，它将在P(mutex)上等待。<br/>
<h2 id="anchor006">死锁</h2><br/>
多个进程可能同时竞争系统中的有限资源。如果某一进程请求已被其它进程占用的资源而进入阻塞状态，
导致系统其它进程也因请求资源处于阻塞状态这种阻塞等待可能永无止境。这种情况就叫做死锁。<br/>
<h3 id="anchor007">死锁的定义和死锁产生的必要条件</h3><br/>
<h4>资源的特性</h4><br/>
计算机系统中的资源分为两类：可抢占和不可抢占。对于可抢占资源，通过资源的重新分配，很容易解决
存在的死锁情况。不可抢占资源，又叫做临界资源，如慢速设备、共享变量和队列等。对于这类资源，
当资源从占用进程夺走时，可能引起进程计算失败。通常情况下，死锁涉及的是不可抢占的资源。<br/>
<h4>死锁的定义</h4><br/>
一组进程是死锁的，是指这一组中的每个进程都正等待这一组中的其它进程所占有的资源时可能引起的一种错误现象。
<br/>
<h4 id="anchor008">死锁产生的必要条件</h4><br/>
产生死锁的4个必要条件:<br/>
<ol>
    <li>互斥条件，每个资源是不可共享的，它或者已经分配给一个进程，或者空闲</li>
    <li>保持和等待条件，进程因请求资源而被阻塞等待时，对已经分配给它的资源保持不放</li>
    <li>不剥夺条件，进程所获得的资源在未使用完之前，不能被其它进程强行剥夺，只能由获得资源的进程释放</li>
    <li>循环等待条件，存在一个进程循环链，链中有两个或多个进程，每一个进程正在等待链中下一个成员保持的资源</li>
</ol>
<br/>
<h4 id="anchor009">死锁产生的原因</h4><br/>
死锁产生的原因:<br/>
<ol>
    <li>系统资源配置不足，因而引起进程竞争资源</li>
    <li>系统的各并发进程请求资源的随机性，这包括所请求的资源类别和数量</li>
    <li>各进程在系统中异步向前推进，造成进程推进顺序的非法性</li>
</ol>
<br/>
<h4 id="anchor010">解决死锁的方法</h4><br/>
<ol>
    <li>忽略不计(鸵鸟算法)出现死锁，重启系统</li>
    <li>预防死锁，通过破坏死锁的4个必要条件来避免</li>
    <li>避免死锁，在进程请求分配资源时，采用银行家算法防止系统进入不安全状态</li>
    <li>检测和恢复死锁，通过设置一个死锁检测机构，进行死锁检测的。
        一旦检测出系统存在死锁，通过逐一撤销进程等方法使系统恢复
    </li>
</ol>
<br/>
<h3 style="color:red" id="anchor011">银行家算法</h3><br/>
银行家算法的陈述如下：<br/>
1)当一个进程提出一个资源请求时，假定分配给它，并调用检查系统状态安全行的算法。
如果系统是安全的，则对申请者的假分配变为实际的分配。否则推迟它的请求，让其阻塞等待。<br/>
2)检查系统状态安全性的算法。根据系统剩余的资源情况，银行家进行检查，看满足请求者的要求后，
是否仍使系统中的所有进程都能正常完成（即能找到一个进程完成序列）。若能，系统使安全的。否则系统是不安全的。<br/>
由银行家算法可推倒出：<div style="color:red">对于系统中有n个并发进程共享使用m个同类资源时，
    若每个进程需要的最大资源数量为x，仅当m,n和x满足如下的不等式时，才能保证系统处于安全状态:</div>
<div style="color:red">n(x-1)+1&lt;=m</div><br/>
已知m,n时，x得到如下解:<br/>
<pre>
        1  (m&lt;=n)

    x =

        1 + (m-1)/n (m&gt;n)
</pre>

</body>
</html>