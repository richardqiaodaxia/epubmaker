<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
        PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>存储器管理</title>
</head>
<body>
<h2>存储管理</h2><br/>
<h3>分区分配</h3><br/>
<h4 id="anchor001">固定式分区</h4><br/>
固定式分区是适合多道程序运行的最简单的存储器管理，它把主存用户区预先划分成几个大小不等的分区，
当进程到达时，选择一个适合进程要求的最小空闲分区分给进程；没有适合的空闲分区时，让其等待。
为了充分利用存储器，将进程按照请求空间的大小在不同的分区排队等待。<br/>
这种方法管理简单，但有可能出现大分区队列空闲，而小分区队列拥挤的情况。<br/>
<h4 id="anchor002">可变式分区</h4><br/>
为了提高存储器的利用率，存储空间的划分推迟到装入进程时进行。当进程要求运行时，系统从空闲的存储空间
划分出大小正好等于进程大小的一个存储区分配给进程。这种技术叫做可变式分区或动态分区。
使用可变式分区技术时，分区的大小和个数在系统中不断变化。
<h4 id="anchor003">可变式分区和固定式分区的比较</h4><br/>
可变式分区欲固定式分区相比，当进程不断进出主存时，对于进程的数量、大小及其占用的存储位置，后者保持不变，前者会
不断改变。可变式分区能改进存储器的使用效率，却使存储的分配和释放工作复杂了。<br/>

<h2>虚拟存储器</h2><br/>

<h3 id="anchor004">虚拟存储器的概念</h3><br/>
虚拟存储器是为了满足应用对存储器容量的巨大需求而为用户构造的一个非常大的地址空间
它允许进程的地址空间不必全部进入主存就可以执行，从而使用户在编程时无须担心存储器不足。
实现用户这一要求的方法时系统在设计指令地址时，其指令地址部分能覆盖的地址域远大于实际主存的容量。<br/>

<h2 id="anchor005">页式存储器管理</h2><br/>
页式管理的主要特征是把编址为0，1，2，3...n字节的主存分成大小相等的若干块，又叫页框。运行进程的地址
空间也划分成与主存块同样大小的页或虚页，并依次命名为第0页，第一页...第m/1页<br/>
为了实现分页，硬件把CPU产生的地址分解为页号和页内地址两部分。<br/>

<h3 id="anchor006">页式动态地址变换</h3><br/>
假定进程的地址空间共有7个页，每一页大小1024字节，假定页表在主存始址为500，若程序从第0页开始运行，
某时刻，程序计数器内容为4000。根据分块大小，可知，一个逻辑地址分解的页号<br/>
p = (逻辑地址/页的大小)<sub>取整</sub> = 4000/1024 = 3<br/>
页面地址<br/>
w = (逻辑地址/页的大小)<sub>取余</sub> ＝ (4000 - 1024x3) = 928。<br/>
故硬件将其划分为页号p=3，页内地址w=928。<br/>
假定页表项占用字节数为2
页号在页表中的入口地址=页表始址+页号x页表项占用的字节数=500 + 3x2 = 506<br/>
找到主存块号对应的地址，并且与页内地址拼接<br/>
15x1024+928 = 16288 地址<br/>

<h2 id="anchor007">覆盖与交换技术</h2><br/>
覆盖与交换技术是解决大进程与小主存矛盾的两种存储器管理技术。<br/>

<h3>覆盖</h3><br/>
是指同一主存区可以被一个或多个作业（或进程）的不同程序段重复使用。通常一个进程由若干个功能上
相互独立的程序段组成，进程在依次运行时，也只用到其中的几段，利用这样的事实，就可以让哪些不会同时
执行的程序段公用同一个主存区。为此把可以公用同一个主存区的相互覆盖的程序段叫做覆盖段。<br/>
覆盖技术的主要特点时打破了必须将一个进程的全部信息装入主存后才能运行的限制，在一定程度上解决了小主存运行
大进程的矛盾，在逻辑上扩充了主存。但当同时运行程序的代码量大于主存时仍不能运行。<br/>

<h3 id="anchor008">交换</h3><br/>
交换技术被广泛地运用于早期的小型分时系统的存储器管理中。其目的，一方面解决主存容量不够大的矛盾；
另一方面使各分时用户能保证合理的相应时间。所谓交换就是系统根据需要把主存中暂时不运行的进程的某个或
某些部分或全部信息移到外存，而把外存中的某个（某些）进程移到相应的主存区，并使其投入运行。<br/>

<h2 id="anchor009">页面淘汰算法</h2><br/>

<h3>最佳置换(OPT)算法</h3><br/>
一个理想的淘汰算法应该是：选择以后不再访问的页或经很长时间之后才可能访问的页进行淘汰。这样的算法是
不现实的，因为产生却页时，操作系统不知到每个页的下次访问时间。通常使用这种算法去衡量所采用算法的性能好坏<br/>

<h3 id="anchor010">先进先出淘汰算法(FIFO)</h3><br/>
当淘汰一页时，选择在主存驻留时间最长的那一页。操作系统维护一张当前页表。<br/>
<table border="1">
    <tr>
        <td>0</td>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>0</td>
        <td>1</td>
        <td>4</td>
        <td>0</td>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>4</td>
    </tr>
    <tr>
        <td>0</td>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>0</td>
        <td>1</td>
        <td>4</td>
        <td>4</td>
        <td>4</td>
        <td>2</td>
        <td>3</td>
        <td>3</td>
    </tr>
    <tr>
        <td></td>
        <td>0</td>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>0</td>
        <td>1</td>
        <td>1</td>
        <td>1</td>
        <td>4</td>
        <td>2</td>
        <td>2</td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td>0</td>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>0</td>
        <td>0</td>
        <td>0</td>
        <td>1</td>
        <td>4</td>
        <td>4</td>
    </tr>
    <tr>
        <td>F</td>
        <td>F</td>
        <td>F</td>
        <td>F</td>
        <td>F</td>
        <td>F</td>
        <td>F</td>
        <td>S</td>
        <td>S</td>
        <td>F</td>
        <td>F</td>
        <td>S</td>
    </tr>
</table>
<br/>

<h3 id="anchor011">最近最少使用的页面淘汰算法(LRU)</h3><br/>
淘汰那些在最近一段时间里最少使用的一页。它是根据程序执行时所具有的局部性原理考虑的。指在一段时间内，进程集中
在一组子程序或循环中执行，导致所有的存储器访问局限于进程地址空间的一个固定子集。<br/>
LRU算法选择上次访问时间距当前最远的页淘汰。<br/>
利用堆栈记录页的使用情况。每当一个页被引用时，该页总放在栈顶。<br/>
<table border="1">
    <tr>
        <td>0</td>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>0</td>
        <td>1</td>
        <td>4</td>
        <td>0</td>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>4</td>
    </tr>
    <tr>
        <td>0</td>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>0</td>
        <td>1</td>
        <td>4</td>
        <td>0</td>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>4</td>
    </tr>
    <tr>
        <td></td>
        <td>0</td>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>0</td>
        <td>1</td>
        <td>4</td>
        <td>0</td>
        <td>1</td>
        <td>2</td>
        <td>3</td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td>0</td>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>0</td>
        <td>1</td>
        <td>4</td>
        <td>0</td>
        <td>1</td>
        <td>2</td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td></td>
        <td>0</td>
        <td>1</td>
        <td>2</td>
        <td>3</td>
        <td>3</td>
        <td>3</td>
        <td>4</td>
        <td>0</td>
        <td>1</td>
    </tr>
    <tr>
        <td>F</td>
        <td>F</td>
        <td>F</td>
        <td>F</td>
        <td>F</td>
        <td>S</td>
        <td>F</td>
        <td>S</td>
        <td>S</td>
        <td>F</td>
        <td>F</td>
        <td>F</td>
    </tr>
</table>
<br/>

</body>
</html>