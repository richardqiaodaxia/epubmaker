<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <title>Untitled Document</title>
    <style type="text/css">
        .important {
        color: #F00;
        }
    </style>
</head>

<body>
<h2>计算机组成原理</h2>

<p><br/>
    冯。诺依曼 提出存储程序的概念，简要的包括一下几点<br/>1.计算机应由运算器、存储器、控制器、输入设备和输出设备5大基本部件组成<br/>2.计算机内部采用二进制来表示指令和数据<br/>
    3.将编好的程序和原始数据事先存入存储器中，然后再启动计算机工作，这就是存储程序的概念</p>

<h2>计算机的总线结构</h2>

<p>所谓总线是一组能为多个部件服务的公共信息传输线路，</p>

<p>1、单总线结构 各大部件都连接在单一的一组总线上，古将这个单总线称为系统总线；<br/>系统总线包含 地址总线，数据总线，控制总线</p>

<h2>数据的机器层次表示</h2>

<h3>无符号数和带符号数</h3>

<p>所谓无符号数，就是整个机器字长的全部二进制位均表示数值位，相当于数的绝对值</p>

<h3>原码表示法</h3>

<p>原码表示法是一种最常见的机器数表示法，最高位为符号位，符号位为“0”代表该数为正，符号位为1时，表示该数为负。</p>

<h3>补码表示法</h3>

<p>当X为正数时，[X]<sub>补</sub> = [X]<sub>原</sub> = X</p>

<p>当X为负数时，[X]<sub>补</sub> =[X]<sub>原</sub> 除去符号位，各位取反再加1</p>

<p>更加有效的方式是，自低位向高位，尾数的第一个1及其右边的0保持不变，左边的各位取反，负号用1表示</p>

<p>例：</p>

<p>[X]<sub>原</sub> ＝ 1. 111001 1000 求补</p>

<p>[X]<sub>补</sub> ＝ 1. 000110 1000 尾部 的第一个1 和后续的0 不变，其余取反</p>

<p>例：负数</p>

<p>[X]<sub>原</sub> =-0. 10100010 10</p>

<p>[X]<sub>补</sub> = 1. 01011101 10</p>

<h3>补码表示法</h3>

<p>反码表示法与补码有很多类似之处。对于正数这个和真值部分相同</p>

<p>对于负数，将真值的数值部分按位取反。不进行加1操作。</p>

<p>例：纯小数</p>

<p>X = 0. 0110 [X]<sub>反</sub> ＝ X = 0.0110</p>

<p>X = -0.0110 [X]<sub>反</sub> ＝ 1.1001</p>

<p>例：纯整数</p>

<p>X = 1101 [X]<sub>反</sub> = 0 1101 注意要加入符号位</p>

<p>X = -1101 [X]<sub>反</sub> = 1 0010</p>

<h2>计算数的定点表示和浮点表示</h2>

<h3>定点表示法</h3>

<p>所有数据的小数点位置固定不变。通常，把小数点固定在有效数位的最前面或末尾,就形成了两类定点数。</p>
<h4>定点小数</h4>

<p>纯小数，小数点位置固定在最高有效位之前，符号位之后。</p>
<h4>定点整数</h4>

<p>纯整数</p>

<h3>浮点表示法</h3>

<p>让小数点的位置根据需要而浮动，就是浮点数。例如：</p>

<p>N = M X r<sup>E</sup></p>

<p>其中 r 是浮点数阶码的底，与尾数的基数相同，通常r = 2. E和M都是带符号的定点数E叫做阶码，M叫做尾数。在大多数计算机中，尾数为纯小数，常用原码或补码表示；阶码为纯整数，常用移码或补码表示。</p>

<h3>规格化浮点数</h3>

<p>为了提高精度，需要充分利用尾数的有效数位，通常采取浮点数规格化形式，即规定尾数的最高位必须是一个有效值。</p>

<p>一个浮点数的表示形式并不是唯一的。例如二进制数 0.0001101 可以表示为 </p>

<p>0.001101 X 2<sup>-01</sup>、0.01101 X 2<sup>-10</sup>、0.1101 X 2<sup>-11</sup>。。。的形式</p>

<p>其中，只有 0.1101 X 2<sup>-11</sup>是规格化数，注意其中的都是 二进制形式。</p>

<p>规格化浮点数的尾数 M 的绝对值应在 下列范围内：</p>

<p>1/r &lt;= |M| &lt; 1</p>

<p>在尾数用补码表示时，规格化浮点数应满足尾数最高位与符号位不同。</p>

<h3>浮点数阶码的移码表示法</h3>

<p>浮点数的阶码是带符号的定点整数，大多数采用另一种编码方式——移码表示法。</p>

<p>移码就是在真值X的基础上加一个常数，这个常数被称为偏置值，相当于X在数轴上向正方向偏移了若干单位：</p>

<p>[X]<sub>移</sub> = 偏置值 + X</p>

<p>如何选择偏置值：假设阶码共 n + 1 位，则总共有 2<sup>n+1</sup>个无符号整数。这2<sup>n+1</sup>个无符号整数可以对应2<sup>n+1</sup>个阶码的真值。显然，选择偏置值应该使得阶码真值的正数和负数分布均匀，因此居于中间的两个数是
    2<sup>n</sup>-1和2<sup>n</sup>，可以选择这两个数中的任意一个作为偏置值。</p>

<h3>浮点数定义实例</h3>

<p>
    IEEE754标准 阶码的偏置值为 1111111，其余23位为尾数数值</p>
<table border="1">
    <tr>
        <td>m<sub>s</sub></td>
        <td>E</td>
        <td>M</td>
    </tr>
    <tr>
        <td>数符</td>
        <td>阶码 移码表示</td>
        <td>尾数数值位</td>
    </tr>
</table>
<p>例：把(100.25)<sub>10</sub>转换成短浮点数格式：</p>
<ol>
    <li>把十进制数转换为二进制数: (100.25)<sub>10</sub> = (1100100. 01)<sub>2</sub></li>
    <li>规格化二进制数: 1100100.01 = 1.10010001 X 2<sup>6</sup></li>
    <li>计算出阶码的移码: 采用偏置值 1111111 那么移码为 1111111 + 110 = 10000101</li>
    <li>以短格式存储： 符号位 = 0 阶码 = 10000101</li>
    <li>尾数 1<sup></sup>0010001 这个是因为，IEEE754 隐藏了尾数的最高有效位</li>
</ol>
<p>
    最终形成的短浮点数代码为：0:10000101:1001000100000000000000<br/>
    十六进制内容为: 42C88000H
</p>

<h2>十进制数与数串的表示</h2>

<h3>十进制数的编码</h3>

<p>二进制是计算机最合适的数据表示方法，把十进制数的各位数字变成一组对应的二进制代码，用4位二进制数来表示1位十进制数，称作 <span class="important">BCD码</span></p>
<h4>8421编码</h4>

<p>按照4位从高到低 权重 8 , 4, 2, 1 的形式进行编码，这个编码不是16进制的形式，</p>

<p>比如 34 用 BCD 8421 形式，那么应该是 0011 0100 的形式。</p>

<h4>2421编码</h4>
<h4>余3码</h4>
<h4>格雷码</h4>

<h2>数据校验码</h2>

<h3>奇偶校验码</h3>

<p>奇偶校验码是一种最简单的数据校验码，它的码距等于2,可以检测出一位错误（或奇数位错误），但不能确定出错的位置，也不能检测出偶数位错误。</p>

<p>奇偶校验实现方法是：由若干位有效信息（如一个字节），再加上一个二进制位（校验位）组成校验码，校验位的取值（0或1）将使整个校验码中的“1”的个数为奇数或偶数，所以有如下两种可供选择的校验规律：</p>
<ul type="disc">
    <li>奇校验——整个校验码中“1”的个数为奇数</li>
    <li>偶校验——整个校验码中“1”的个数为偶数</li>
</ul>
<h3>简单横向奇偶校验</h3>

<p class="important">所谓奇偶校验，就是采用奇校验的时候，最终生成的含有校验信息的数据，当中的1的个数为奇数。</p>
<table border="1">
    <tr>
        <td>有效信息</td>
        <td>奇校验码</td>
        <td>偶校验码</td>
    </tr>
    <tr>
        <td>00000000</td>
        <td>100000000</td>
        <td>000000000</td>
    </tr>
    <tr>
        <td>01010100</td>
        <td>001010100</td>
        <td>101010100</td>
    </tr>
    <tr>
        <td>01111111</td>
        <td>001111111</td>
        <td>101111111</td>
    </tr>
    <tr>
        <td>11111111</td>
        <td>111111111</td>
        <td>011111111</td>
    </tr>
</table>
<h3>循环冗余校验码 CRC</h3>
<h4>循环冗余校验码的编码方法</h4>

<p>循环冗余校验码是由两部分组成的，如表格</p>
<table border="1">
    <tr>
        <td>信息位</td>
        <td>校验位</td>
    </tr>
    <tr>
        <td>N位</td>
        <td>K位</td>
    </tr>
</table>

<p>左边为信息位，右边为校验位，若信息位为N位，校验位为K位，则该校验码被称为</p>

<p>(N + K, N)码。</p>

<p>编码规则如下：</p>
<ol>
    <li>把待编码的N位有效信息表示为多项式 M(X)</li>
    <li>把M(X)左移K位，得到 M(X) x X<sup>k</sup>，这样空出了K位，以便拼装K位余数(即校验位)</li>
    <li>选取一个K + 1位的产生多项式G(X)，对M(X) x X<sup>k</sup>作模2除</li>
    <li>把左移的K位以后的有效信息与余数R(X)作模2加减，拼接为CRC码，此时 CRC码共有N + K位</li>
</ol>
<h2>指令系统</h2>

<h3>寻址技术</h3>
<h4>基本的寻址方式</h4>
<table border="1">
    <tr>
        <td>寻址方式</td>
        <td>指令</td>
        <td>说明</td>
    </tr>
    <tr>
        <td>立即</td>
        <td>OP 立即数</td>
        <td>直接是操作数，不是地址，OP可以直接用</td>
    </tr>
    <tr>
        <td>寄存器</td>
        <td>OP 寄存器</td>
        <td>寄存器中保存着实际的操作数，通过寄存器进行寻址</td>
    </tr>
    <tr>
        <td>直接寻址</td>
        <td>OP 直接地址</td>
        <td>直接地址是一个内存地址，这个内部存放着操作数</td>
    </tr>
    <tr>
        <td>间接寻址</td>
        <td>OP @间接地址</td>
        <td>间接地址指区域中存放着另一地址，另一地址包含操作数</td>
    </tr>
    <tr>
        <td>寄存器间接寻址</td>
        <td>OP @寄存器</td>
        <td>寄存器中存放一个地址，这个地址包含数据</td>
    </tr>
    <tr>
        <td>变址寻址</td>
        <td></td>
        <td>将寄存器中的地址与形式地址相加得出来实际地址</td>
    </tr>
    <tr>
        <td>基址寻址</td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>相对寻址</td>
        <td></td>
        <td></td>
    </tr>
    <tr>
        <td>页面寻址</td>
        <td></td>
        <td></td>
    </tr>
</table>
<h3>堆栈与堆栈操作</h3>
<h4>堆栈结构</h4>

<p>堆栈区通常是主存储器中指定的一个区域，也可以专门设置一个小而快的存储器作为堆栈区。</p>

<p>寄存器堆栈和存储器堆栈</p>

<h3>指令类型</h3>
<h4>数据传送类指令</h4>

<p>一般传送指令 mov等</p>

<p>堆栈操作类指令：push, pop</p>

<p>数据交换指令</p>
<h4>运算类指令</h4>

<p>算术运算类指令</p>

<p> 逻辑运算类指令 按位测，按位清，按位置，按位修改</p>
<h4> 移位类指令</h4>

<p>程序控制类指令</p>

<p> 转移指令，跳转等</p>

<p> 子程序调用指令；</p>

<p> 返回指令</p>
</body>
</html>
